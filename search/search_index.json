{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenue sur les cours du renard !","text":"<p>Panne sur l'affichage math\u00e9matique</p> <p>L'affichage des notations 'math\u00e9matiques' est hors service.</p> <p>Ce site utilise un outil externe pour afficher les formules math\u00e9matiques, or le site qui h\u00e9berge l'outil semble \u00eatre actuellement hors ligne. </p> <p>Le rendu des formules math\u00e9matiques sur le site est donc temporairement indisponible.</p>"},{"location":"#contenu","title":"Contenu","text":"<p>Ce site est un r\u00e9sum\u00e9 de la plupart des cours de terminale.</p> <ul> <li>Math\u00e9matiques</li> <li>NSI</li> <li>Plus \u00e0 venir !</li> </ul>"},{"location":"#notes","title":"Notes","text":"<p>Le site est tout nouveau et en pleine construction, et je suis pour l'instant le seul \u00e0 le g\u00e9rer. Le contenu reste donc pour l'instant assez limit\u00e9.</p>"},{"location":"Mathematiques/","title":"Math\u00e9matiques","text":""},{"location":"Mathematiques/Probabilit%C3%A9es/","title":"A venir...","text":""},{"location":"Mathematiques/python/","title":"Python en math\u00e9matiques","text":"<p>Bien que les exercices en Python soient souvent n\u00e9glig\u00e9s, ils repr\u00e9sentent pourtant une opportunit\u00e9 pour obtenir un ou deux points facilement.</p>"},{"location":"Mathematiques/python/#1-boucles","title":"1. boucles","text":"<p>Quasiment la totalit\u00e9 des exercices de code Python en math\u00e9matiques sont des boucles \u00e0 compl\u00e9ter, afin de calculer un certain seuil d'une limite.</p> <p>Les boucles permettent de r\u00e9p\u00e9ter un code. Chaque ex\u00e9cution de la boucle est appel\u00e9 une it\u00e9ration</p> <p>En python, il existe deux types de boucle:</p>"},{"location":"Mathematiques/python/#11-les-boucle-for","title":"1.1. Les Boucle \"For\"","text":"<p>La boucle <code>for</code> (en fran\u00e7ais \"Pour\") est une boucle qui est ex\u00e9cut\u00e9e pour un nombre d\u00e9termin\u00e9 d'it\u00e9rations</p> <p>Exemple: Pour <code>i</code> compris entre 0 et 10 :</p> Boucle 'for'<pre><code>nombre = 0\nfor i in range (0, 10):\n    nombre = nombre + 1\nprint(nombre)\n\n&gt;&gt;&gt; 10\n</code></pre>"},{"location":"Mathematiques/python/#12-les-boucle-while","title":"1.2. Les Boucle \"While\"","text":"<p>La boucle <code>while</code> (en fran\u00e7ais \"tant que\") est une boucle qui est ex\u00e9cut\u00e9e tant qu'une certaine condition est valide </p> <p>Exemple: tant que la variable <code>nombre</code> est inf\u00e9rieur \u00e0 10 :</p> Boucle 'while'<pre><code>nombre = 0\nwhile nombre &lt; 10:\n    nombre = nombre + 1\nprint(nombre)\n\n&gt;&gt;&gt; 10\n</code></pre> <p>attention aux boucles infinies !</p> <p>Assurez-vous \u00e0 ce que la condition d'arr\u00eat de la boucle soit atteinte, autrement elle deviendra une boucle infini !</p> <p>Par exemple, prenons le code suivant: <pre><code>nombre = 5\nwhile nombre &gt; 4:\n    nombre = nombre + 1\nprint(nombre)\n</code></pre> Ici la boucle while va incr\u00e9menter la variable <code>nombre</code> tant que <code>nombre</code> est sup\u00e9rieur \u00e0 4, le programme ne va donc jamais s'arr\u00eater !</p>"},{"location":"Mathematiques/python/#2-exercices","title":"2. Exercices","text":"<p>2.1 Boucles 'For'</p> <p>A venir</p> <p>2.2 Boucles 'While'</p> <p>g(n) = \\(0.1*0.5^{n-1}+0.4\\)</p> <p>Compl\u00e9ter les lignes 4 et 6 de la fonction suivante afin qu'elle renvoie le plus petit rang \u00e0 partir duquel les termes de la suite \\((g_n)\\) sont tous inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(0.4+e\\), o\u00f9 e est un nombre r\u00e9el strictement positif. <pre><code>def seuil(e):\n    g=0.5\n    n=1\n    while............:\n        g=0.5*g+0.2\n        n=.........\n    return(n)\n</code></pre></p> Corrig\u00e9 <pre><code>def seuil(e):\n    g=0.5\n    n=1\n    while g &gt; 0.4+e:\n        g=0.5*g+0.2\n        n= n+1\n    return(n)\n</code></pre>"},{"location":"Mathematiques/suites/","title":"Suites num\u00e9riques et r\u00e9currence","text":""},{"location":"Mathematiques/suites/#introduction","title":"Introduction","text":"<p>Dans ce chapitre, il s'agit de d\u00e9velopper la notion de suite, \u00e9tudi\u00e9e en Premi\u00e8re, et d'utiliser les propri\u00e9t\u00e9s de nouvelles fonctions introduites en Terminale.</p>"},{"location":"Mathematiques/suites/#1-suites-particulieres","title":"1. Suites particuli\u00e8res","text":""},{"location":"Mathematiques/suites/#11-suites-arithmetiques","title":"1.1 Suites arithm\u00e9tiques","text":"<p>La suite \\((u_n)\\) est une suite arithm\u00e9tique si :</p> <p>\u00a0\u00a0Pour tout \\(n \\in \\mathbb{I}\\) (o\u00f9 \\(\\mathbb{I}\\) est un sous ensemble de \\(\\mathbb{N}\\)), on a:</p> \\[ u_{n+1}-u_n = r\\] <p>Exercice</p> <p>soit la suite \\((u_n)\\) d\u00e9finie par :</p> <p>\u00a0\u00a0pour tout \\(n \\in \\mathbb{N}\\text{\\ \\{0,1,2\\}, } u_{n} = 3n+5\\)</p> <p>Donner la nature de la suite \\((u_n)\\)</p> Solution <p>Pour tout \\(n \\in \\mathbb{N}\\text{\\ \\{0,1,2\\}, } u_{n+1} - u_n = 3(n+1)+5-(3n+5) = 3\\) (la diff\u00e9rence de 2 termes cons\u00e9cutifs ne d\u00e9pend pas de \\(n\\)). Donc \\((u_n)\\) est une suite arithm\u00e9tique de raison \\(r=3\\) et de \\(1^{er}\\) terme \\(u_3=14\\)</p>"},{"location":"Mathematiques/suites/#12-suites-geometriques","title":"1.2 Suites g\u00e9om\u00e9triques","text":"<p>La suite \\((V_n)\\) est une suite g\u00e9om\u00e9trique si :</p> <p>\u00a0\u00a0Pour tout \\(n \\in \\mathbb{I}\\) (o\u00f9 \\(\\mathbb{I}\\) est un sous ensemble de \\(\\mathbb{N}\\)), on a:</p> \\[ V_{n+1}=qV_n\\] remarque <p>On pr\u00e9cisera toujours la raison \\(q\\) et le \\(1^{er}\\) terme de la suite.</p> <p>Exercice</p> <p>soit la suite \\((V_n)\\) d\u00e9finie par :</p> <p>\u00a0\u00a0pour tout \\(n \\in \\mathbb{N}\\text{\\ \\{0,1\\}, } V_{n} = \\frac{3}{2^n}\\)</p> <p>Donner la nature de la suite \\((V_n)\\).</p> Solution <p>Pour tout \\(n \\in \\mathbb{N}\\text{\\ \\{0,1\\}, } V_{n+1} = \\frac{3}{3^{n+1}} = \\frac{1}{2} \\times \\frac{3}{2^n} = \\frac{1}{2}V_n\\).</p> <p>Donc \\((V_n)\\) est une suite g\u00e9om\u00e9trique de raison \\(q=\\frac{1}{2}\\) et de \\(1^{er}\\) terme \\(V_2=\\frac{3}{4}\\)</p>"},{"location":"Mathematiques/suites/#2-limite-dune-suite","title":"2. Limite d'une suite","text":""},{"location":"Mathematiques/suites/#31-notations","title":"3.1 Notations","text":"<p>Une suite num\u00e9rique est une application de \\(\\mathbb{N}\\) dans \\(\\mathbb{R}\\) :</p> <p>attention !</p> <p>En g\u00e9n\u00e9ral \\(u_n\\) n'est pas le \\(n^{i\u00e8me}\\) terme de la suite.</p> <p>Par exemple si \\(u_0\\) est le premier terme de la suite \\(u_n\\) est le \\((n+1)^{i\u00e8me}\\) terme.</p> \\[u : \\{ {\\mathbb{N} \\rightarrow \\mathbb{R}} \\ {n \\rightarrow u(n)}\\] <p>Au lieu de u(n) on \u00e9crit \\(u_n\\).</p> <p>La suite \\(u\\) se note en g\u00e9n\u00e9ral \\((u_n)_{n \\in \\mathbb{N}}\\) ou plus simplement .</p> <p>On dit aussi que \\((u_n)\\) est le terme g\u00e9n\u00e9ral de rang \\(n\\) ou d'indice \\(n\\) de la suite \\((u_n)_{n \\in \\mathbb{N^{*}}}\\).</p> <p>Si \\((u_0)\\) n'est pas d\u00e9fini, la suite est not\u00e9e \\((u_n)_{n \\in \\mathbb{N^{*}}}\\). De m\u00eame, si \\((u_0)\\) et \\((u_1)\\) ne sont pas d\u00e9finis, la suite sera not\u00e9e \\((u_n)_{n \\ge 2}\\).</p> <p>D\u00e9finition</p> <p>Soit \\((u_n)\\) une suite num\u00e9rique.</p>"},{"location":"Mathematiques/suites/#3-operations-sur-les-limites","title":"3. Op\u00e9rations sur les limites","text":"<p>Soit \\(u\\) et \\(v\\) deux suites.</p>"},{"location":"Mathematiques/suites/#31-somme","title":"3.1 Somme","text":"si \\(u\\) tend vers \\(l\\) \\(l\\) \\(l\\) \\(+\\infty\\) \\(+\\infty\\) \\(+\\infty\\) et si \\(v\\) tend vers \\(l'\\) \\(+\\infty\\) \\(-\\infty\\) \\(+\\infty\\) \\(+\\infty\\) \\(-\\infty\\) alors \\(u+v\\) tend vers \\(l+l'\\) \\(+\\infty\\) \\(-\\infty\\) \\(+\\infty\\) \\(+\\infty\\) F.I."},{"location":"Mathematiques/suites/#32-produit","title":"3.2 Produit","text":"si \\(u\\) tend vers \\(l\\) \\(l&gt;0\\) \\(l&gt;0\\) \\(l&lt;0\\) \\(l&lt;0\\) \\(+\\infty\\) \\(+\\infty\\) \\(-\\infty\\) 0 et si \\(v\\) tend vers \\(l'\\) \\(+\\infty\\) \\(-\\infty\\) \\(+\\infty\\) \\(-\\infty\\) \\(+\\infty\\) \\(-\\infty\\) \\(-\\infty\\) \\(+\\infty\\) alors \\(u*v\\) tend vers \\(l*l'\\) \\(+\\infty\\) \\(-\\infty\\) \\(-\\infty\\) \\(+\\infty\\) \\(+\\infty\\) \\(-\\infty\\) \\(+\\infty\\) F.I."},{"location":"Mathematiques/suites/#33-quotient","title":"3.3 Quotient","text":"si \\(u\\) tend vers \\(l\\) \\(l\\) \\(+\\infty\\) \\(+\\infty\\) \\(-\\infty\\) \\(-\\infty\\) 0 \\(\\pm\\infty\\) et si \\(v\\) tend vers \\(l\\neq0\\) \\(\\pm\\infty\\) \\(l'&gt;0\\) \\(l'&lt;0\\) \\(l'&gt;0\\) \\(l'&lt;0\\) 0 \\(\\pm\\infty\\) alors \\(\\frac{u}{v}\\) tend vers \\(\\frac{l}{l'}\\) 0 \\(+\\infty\\) \\(-\\infty\\) \\(-\\infty\\) \\(+\\infty\\) F.I. F.I."},{"location":"Mathematiques/suites/#4-theoreme-de-la-convergence-monotone","title":"4. Th\u00e9or\u00e8me de la convergence monotone","text":"<p>D\u00e9finition</p> <p>Une suite croissante et major\u00e9e est convergente</p> <p>Une suite d\u00e9croissante et minor\u00e9e est convergente</p>"},{"location":"NSI/","title":"NSI","text":""},{"location":"NSI/1.%20Bases%20de%20donnees/","title":"1. Bases de donn\u00e9es","text":"<p>Une section m\u00e9mo pour les fonctions et d\u00e9finitions de base en NSI</p>"},{"location":"NSI/1.%20Bases%20de%20donnees/#1-definitions","title":"1. D\u00e9finitions","text":"<p>int\u00e9grit\u00e9 de domaine</p> <p>Les valeurs doivent appartenir au domaine fix\u00e9 pour chaque attribut</p> <p>int\u00e9grit\u00e9 de relation (ou contrainte d'unicit\u00e9)</p> <p>Chaque tuple est unique et doit \u00eatre identifi\u00e9 par une cl\u00e9 primaire qui ne peut pas \u00eatre nulle.</p> <p>Par cons\u00e9quent, une valeur de cl\u00e9 primaire ne peut appara\u00eetre qu'une fois dans la relation.</p> <p>int\u00e9grit\u00e9 de r\u00e9f\u00e9rence (ou int\u00e9grit\u00e9 r\u00e9f\u00e9rencielle)</p> <p>Entre deux relations: toute cl\u00e9 \u00e9trang\u00e8re doit faire r\u00e9f\u00e9rence \u00e0 une cl\u00e9 primaire d'une autre table.</p> <p>Par cons\u00e9quent, la valeur d'une cl\u00e9 \u00e9trang\u00e8re doit toujours \u00eatre \u00e9galement une des valeurs de la cl\u00e9 r\u00e9f\u00e9renc\u00e9e.</p>"},{"location":"NSI/2.%20Arbres/","title":"2. Arbres","text":"<p>Les arbres sont des types abstraits tr\u00e8s utilis\u00e9s en informatique. Ce sont des structures de donn\u00e9es non lin\u00e9aires. On les utilise notamment quand on a besoin d'une structure hi\u00e9rarchique des donn\u00e9es.</p> <p>Un arbre est constitu\u00e9 :</p> <ul> <li> <p>d'une racine</p> </li> <li> <p>de n\u0153uds , sommets interm\u00e9diaires de l'arbre</p> </li> <li> <p>de feuilles: sommets \"finaux\" de l'arbre</p> </li> <li> <p>et de branches, qui relient les \u00e9l\u00e9ments pr\u00e9c\u00e9dents entre eux</p> </li> </ul>"},{"location":"NSI/2.%20Arbres/#21-parcourir-un-arbre","title":"2.1. Parcourir un arbre","text":""},{"location":"NSI/2.%20Arbres/#211-principe","title":"2.1.1 Principe","text":"<p>On part de la racine en posant toujours sa main gauche sur une branche, et on avance en laissant celle-ci pos\u00e9e. On passe par ce principe par tous les n\u0153uds de l'arbre. Cette forme de parcours sur les arbres binaires s\u2019appelle le parcours en profondeur main gauche.</p> <p>Application: sortir d'un labyrinthe.</p>"},{"location":"NSI/2.%20Arbres/#212-parcours","title":"2.1.2 Parcours","text":"<p>L\u2019ordre dans lequel est fait ce traitement donne trois parcours possibles :</p> 1. Parcours pr\u00e9fixe2. Parcours infixe3. Parcours suffixe (ou postfixe) <p>Ordre pr\u00e9fixe : Descente vers le sous-arbre gauche.</p> <p>V\u00e9rifiez que l\u2019arbre est bien parcouru dans l\u2019ordre suivant : A, B, C, E, D, F, G, I, H, J</p> <p>Ordre infixe : Passage du sous-arbre gauche au sous-arbre droit.</p> <p>V\u00e9rifiez que l\u2019arbre est bien parcouru dans l\u2019ordre suivant : C, E, B, D, A, I, G, F, H, J</p> <p>Ordre suffixe (ou postfixe) : Remont\u00e9e depuis le sous-arbre droit.</p> <p>V\u00e9rifiez que l\u2019arbre est bien parcouru dans l\u2019ordre suivant : C, E, D, B, I, G, J, H, F, A</p> Parcourir un arbre en largeur <p>Ce parcours aussi qualifi\u00e9 de hi\u00e9rarchique est par nature it\u00e9ratif</p> <p>Principe : on parcourt tous les noeuds de hauteur 1 (la racine), puis tous les noeuds de hauteur 2, ceux de hauteur 3 etc. Le parcours se fait en g\u00e9n\u00e9ral de gauche \u00e0 droite.</p> <p>On dit alors que le parcours se fait, en fait, par hauteur (profondeur) par rapport \u00e0 la racine.</p> <p></p> <p>V\u00e9rifier que l'arbre ci-dessous est bien parcouru en largeur dans l'ordre suivant : A, B, F, C, D, G, H, E, I, J</p>"},{"location":"NSI/2.%20Arbres/#22-arbre-binaire","title":"2.2. Arbre binaire","text":"<p>Un arbre est dit binaire lorsque tout les noeuds sont d'arit\u00e9 au maximum \u00e9gal \u00e0 2 (1)</p> <ol> <li>C'est \u00e0 dire : les noeuds peuvent avoir au maximum 2 branches</li> </ol>"},{"location":"NSI/2.%20Arbres/#221-algorithme","title":"2.2.1 Algorithme","text":"<p>Taille<pre><code>def taille (self):\n    ''' retourne la taille de l'arbre avec m\u00e9thode r\u00e9cursive'''\n    TailleG = 0\n    TailleD = 0\n    if self.gauche != None :\n            TailleG = self.gauche.taille()\n    if self.droit != None :\n            TailleD = self.droit.taille()\n    return 1 + TailleG + TailleD\n</code></pre> Hauteur<pre><code>def hauteur (self):\n    ''' retourne la hauteur de l'arbre avec m\u00e9thode r\u00e9cursive'''\n    HauteurG = 0\n    HauteurD = 0\n    if self.gauche != None :\n            HauteurG = self.gauche.hauteur()\n    if self.droit != None :\n            HauteurD = self.droit.hauteur()\n    return 1 + max( HauteurG , HauteurD)\n</code></pre> Est une feuille<pre><code>def est_feuille(self):\n    ''' retourne bool\u00e9en si le noeud (sous arbre) est une feuille'''\n    return self.gauche == None and self.droit == None\n</code></pre> Compte feuilles<pre><code>def compte_feuilles(self):\n    ''' Retourne le nombre de feuilles'''\n    CptFG = 0\n    CptFD = 0\n    if self.est_feuille():\n        return 1\n    if self.gauche != None :\n            CptFG = self.gauche.compte_feuilles()\n    if self.droit != None :\n            CptFD = self.droit.compte_feuilles()\n    return CptFG + CptFD\n</code></pre></p>"},{"location":"NSI/2.%20Arbres/#23-arbre-binaire-de-recherche-abr","title":"2.3. Arbre Binaire de Recherche (ABR)","text":"<p>Un arbre binaire de recherche est un cas particulier d'arbre binaire.</p> <p>Pour avoir un arbre binaire de recherche :</p> <ul> <li> <p>il faut avoir un arbre binaire !</p> </li> <li> <p>il faut que les cl\u00e9s de noeuds composant l'arbre soient ordonnables (on doit pouvoir classer les noeuds, par exemple, de la plus petite cl\u00e9 \u00e0 la plus grande)</p> </li> <li> <p>soit x un noeud d'un arbre binaire de recherche. La cl\u00e9 de son sousarbre gauche est inf\u00e9rieure \u00e0 la cl\u00e9 du sommet et la cl\u00e9 de son sousarbre droit est sup\u00e9rieur \u00e0 la cl\u00e9 du sommet</p> </li> </ul> <p>Remaque</p> <p>Dans un ABR, pour un sommet quelconque, toutes les cl\u00e9s de son sous-arbre gauche sont inf\u00e9rieure \u00e0 la cl\u00e9 de son sommet et toutes les cl\u00e9s de son sous-arbre droit son sup\u00e9rieures \u00e0 la cl\u00e9 de son sommet.</p> <p>En programmation, on utilise le parcours infixe pour parcourir l'arbre dans l'ordre croissant.</p>"},{"location":"NSI/2.%20Arbres/#231-aglorithmes","title":"2.3.1 Aglorithmes","text":"<p>parcours infixe<pre><code>def parcoursInfixe(arbre):\n    if arbre is None :\n        return\n    parcoursInfixe(arbre.gauche)\n    print(arbre.etiquette, end=' ')\n    parcoursInfixe(arbre.droit)\n</code></pre> recherche ABR<pre><code>def recherche_ABR(arbre, valeur):\n    if arbre is None :\n        return False\n\n    if arbre.etiquette == valeur :\n        return True\n\n    if valeur &lt; arbre.etiquette :\n        return recherche_ABR(arbre.gauche, valeur)\n    else:\n        return recherche_ABR(arbre.droit, valeur)\n</code></pre> insertion ABR<pre><code>def insertion_ABR(arbre, valeur):\nif arbre is None :\n    return Arbre_binaire(valeur)\nelif valeur &lt;= arbre.etiquette :\n    arbre.gauche = insertion_ABR(arbre.gauche, valeur)\nelse:\n    arbre.droit = insertion_ABR(arbre.droit, valeur)\nreturn arbre\n</code></pre></p>"}]}